SUBROUTINE SPCORR_GRD (NSPL1, NSPL2, grid)
! ----------------------------------------------------------------------------------------
! Creator:
!   Martyn Clark, 2006, 2008
!
! Modified:
!    Andy Newman, Aug 2013
! ----------------------------------------------------------------------------------------
! Purpose:
!   Used to define weights needed to compute a spatially correlated grid of random numbers
!    (use the precipitation grid as a template)
!
! ----------------------------------------------------------------------------------------
! Method:
!
!   Based on the matrix-decomposition method described by Clark and Slater (JHM 2006).
!
!   Here the precipitation grid is used as a template.  Later, random fields generated
!   on the precipitation grid are used to perturb precipitation (on the precipitation grid,
!   before it is disaggregated and assigned to individual sub-basins).
!
!   Random fields used to perturb model states are generated by assigning random numbers
!   from the precipitation grid to individual sub-basins.
!
! ----------------------------------------------------------------------------------------
! I/O:
!
!   Input(s):
!   ---------
!    NSPL1: number of location points (1st spatial dimension)
!    NSPL2: number of location points (2nd spatial dimension)
!
! ----------------------------------------------------------------------------------------
! Structures Populated:
!
!   SPCORR in MODULE gridweight.f90
!    * includes the weights and variance assigned to each grid
!
! ----------------------------------------------------------------------------------------
! Future revisions:
!
!   This routine takes alot of time (and memory) for large grids.  Since many gridpoints
!   use the same combination of previously generated points (i.e., w.r.t. their relative
!   location compared to the target point), it should be possible to identify different
!   categories of gridpoints, and make computations for each of those categories.
!
! ----------------------------------------------------------------------------------------
  USE nrtype ! variable types (DP, I4B, etc.)
  USE nr, ONLY: ludcmp, lubksb ! Num. Recipies
  USE nrutil, ONLY: arth ! Num. Recipies utilities
  USE trig_degrees, ONLY: SIND, COSD ! added for the gfortran compiler
  USE linkstruct ! linkage structures
  USE gridweight ! grid correlation structure
  USE qpe_namelist, ONLY: clen ! correlation length
 
  IMPLICIT NONE
! input
  INTEGER (I4B), INTENT (IN) :: NSPL1 ! # points (1st spatial dimension)
  INTEGER (I4B), INTENT (IN) :: NSPL2 ! # points (2nd spatial dimension)
  TYPE (COORDS), INTENT (IN) :: grid ! input coordniate structure containing grid information
! define hyper parameters
  INTEGER (I4B) :: NNST ! number of nests
  INTEGER (I4B) :: NLOC ! number of local points used
!REAL(DP)                                     :: CLEN        ! correlation length
! define looping variables
  INTEGER (I4B) :: IRES ! loop through resolution increments
  INTEGER (I4B) :: INCR ! spacing between grid cells
  INTEGER (I4B) :: ISP1, ISP2 ! loop through lat-lon grid
  INTEGER (I4B) :: JSP1, JSP2 ! loop through local grid
  INTEGER (I4B) :: IPRC ! counter for # points generated
! identify previously generated points
  INTEGER (I4B) :: K ! counter for prev generated points
  INTEGER (I4B) :: MAXP ! max # of prev generated points
  INTEGER (I4B) :: IPREV, JPREV ! loop through previously gen points
  INTEGER (I4B) :: IERR ! error code for allocate statements
  LOGICAL (LGT), DIMENSION (:, :), ALLOCATABLE :: GMSK ! x-y mask
  INTEGER (I4B) :: NPTS ! # previously generated points
  INTEGER (I4B), DIMENSION (:), ALLOCATABLE :: IPOS, JPOS ! (i,j) index of prev generated points
! compute correlation between points
  REAL (DP) :: LAT1, LON1 ! lat-lon of 1st prev generated point
  REAL (DP) :: LAT2, LON2 ! lat-lon of 2nd prev generated point
  REAL (DP) :: DIST ! distance between points (km)
  REAL (SP), DIMENSION (:, :), ALLOCATABLE :: CORR ! correlation among prev generated points
  REAL (SP), DIMENSION (:), ALLOCATABLE :: GVEC ! corr btw prev gen pts & current point
! compute weights and variance
  REAL (SP), DIMENSION (:), ALLOCATABLE :: TWGT ! copy of GVEC
  INTEGER (I4B), DIMENSION (:), ALLOCATABLE :: INDX ! row permutation (ludcmp)
  REAL (SP) :: TMP ! identifier (ludcmp)
  REAL (DP), DIMENSION (:), ALLOCATABLE :: WGHT ! weight applied to each previous point
  REAL (DP) :: SDEV ! standard deviation of estimate
  INTEGER (I4B) :: N ! # of prev generated points
  LOGICAL (LGT), SAVE :: INIT = .TRUE. ! true for first call to spcorr_grd
 
! output (none) -- structures updated in gridweight.f90
! ----------------------------------------------------------------------------------------
! (0) CHECK THAT SPCORR IS NOT POPULATED ALREADY
! ----------------------------------------------------------------------------------------
  IF ( .NOT. INIT) THEN
   IF (ASSOCIATED(SPCORR)) RETURN
  END IF
! ----------------------------------------------------------------------------------------
! (1) DEFINE HYPER-PARAMETERS
! ----------------------------------------------------------------------------------------
  NNST = 10 ! number of nests
  NLOC = 3 ! number of local points to include in the estimation
 
! ----------------------------------------------------------------------------------------
! (2) ALLOCATE SPACE FOR OUTPUT ARRAYS
! ----------------------------------------------------------------------------------------
! define the maximum number of previously generated points
  MAXP = (NLOC*2+1) ** 2
! allocate space for the mask
  IF (ALLOCATED(GMSK)) THEN
   DEALLOCATE (GMSK, STAT=IERR)
   IF (IERR .NE. 0) CALL EXIT_SCRF (1, ' problem deallocating space for mask ')
  END IF
  ALLOCATE (GMSK(NSPL1, NSPL2), STAT=IERR)
  IF (IERR .NE. 0) CALL EXIT_SCRF (1, ' problem allocating space for mask ')
! nullify pointers
  IF (INIT) NULLIFY (SPCORR, IORDER, JORDER)! in MODULE gridweight
! allocate space for the correlation structure (SPCORR has a pointer structure)
  IF (ASSOCIATED(SPCORR)) THEN
   DEALLOCATE (SPCORR, STAT=IERR)
   IF (IERR .NE. 0) CALL EXIT_SCRF (1, ' problem deallocating space for the spatial correlation structure ')
  END IF
  ALLOCATE (SPCORR(NSPL1, NSPL2), STAT=IERR)
  IF (IERR .NE. 0) CALL EXIT_SCRF (1, ' problem allocating spatial corr struct ')
  IF (INIT) THEN
   DO ISP1 = 1, NSPL1
    DO ISP2 = 1, NSPL2
     NULLIFY (SPCORR(ISP1, ISP2)%IPOS, SPCORR(ISP1, ISP2)%JPOS, SPCORR(ISP1, ISP2)%WGHT)
    END DO
   END DO
  END IF
! allocate space for the processing order
  IF (ASSOCIATED(IORDER)) THEN
   DEALLOCATE (IORDER, STAT=IERR)
   IF (IERR .NE. 0) CALL EXIT_SCRF (1, ' problem deallocating space for the processing order ')
  END IF
  IF (ASSOCIATED(JORDER)) THEN
   DEALLOCATE (JORDER, STAT=IERR)
   IF (IERR .NE. 0) CALL EXIT_SCRF (1, ' problem deallocating space for the processing order ')
  END IF
  ALLOCATE (IORDER(NSPL1*NSPL2), JORDER(NSPL1*NSPL2), STAT=IERR)
  IF (IERR .NE. 0) CALL EXIT_SCRF (1, ' problem allocating space for the processing order ')
! ----------------------------------------------------------------------------------------
! (3) LOOP THROUGH THE DIFFERENT GRID RESOLUTIONS (PROCESS COARSE RESOLUTION FIRST)
! ----------------------------------------------------------------------------------------
  SDEV = 0D0 ! Initialize SDEV (added to account for the first point)  EÃ–H
  IPRC = 0 ! counter for the number of grid points processed
  GMSK = .FALSE. ! initialize a logical array to identify which points have been processed
  DO IRES = NNST - 1, 0, - 1
   INCR = 2 ** IRES ! increment (2**4=16, 2**3=8, 2**2=4, 2**1=2, 2**0=1)
   PRINT *, 'Working on Loop: ', IRES
 ! ---------------------------------------------------------------------------------------
 ! (4) LOOP THROUGH THE LAT-LON OF THE GRID AT A GIVEN RESOLUTION
 ! ---------------------------------------------------------------------------------------
   DO ISP1 = 1, NSPL1, INCR
    DO ISP2 = 1, NSPL2, INCR
   ! check that "current" point has not been generated yet
     IF ( .NOT. GMSK(ISP1, ISP2)) THEN
    ! allocate space to store the (i,j) position, and weights
      IF (ALLOCATED(IPOS)) THEN
       DEALLOCATE (IPOS, STAT=IERR)
       IF (IERR .NE. 0) CALL EXIT_SCRF (1, ' problem deallocating ipos ')
      END IF
      IF (ALLOCATED(JPOS)) THEN
       DEALLOCATE (JPOS, STAT=IERR)
       IF (IERR .NE. 0) CALL EXIT_SCRF (1, ' problem deallocating jpos ')
      END IF
      IF (ALLOCATED(WGHT)) THEN
       DEALLOCATE (WGHT, STAT=IERR)
       IF (IERR .NE. 0) CALL EXIT_SCRF (1, ' probelm deallocating wght ')
      END IF
      ALLOCATE (IPOS(MAXP), JPOS(MAXP), STAT=IERR)
      IF (IERR .NE. 0) CALL EXIT_SCRF (1, ' problem allocating (i,j) position ')
      ALLOCATE (WGHT(MAXP), STAT=IERR)
      IF (IERR .NE. 0) CALL EXIT_SCRF (1, ' problem allocating space for weights ')
    ! increment IPRC
      IPRC = IPRC + 1
    ! save the (i,j) position of iprc
      IORDER (IPRC) = ISP1
      JORDER (IPRC) = ISP2
    ! ------------------------------------------------------------------------------------
    ! (5) IDENTIFY PREVIOUSLY GENERATED POINTS
    ! ------------------------------------------------------------------------------------
      K = 0 ! initialize the number of previous points generated to zero
    ! loop through points in the local neighbourhood
      DO JSP1 = Max (1, ISP1-(INCR*NLOC)), Min (ISP1+(INCR*NLOC), NSPL1)
       DO JSP2 = Max (1, ISP2-(INCR*NLOC)), Min (ISP2+(INCR*NLOC), NSPL2)
      ! check to see if the "local" point has been generated previously
        IF (GMSK(JSP1, JSP2)) THEN ! local point has been previously generated
         K = K + 1
       ! save the (i,j) position of the previously generated point
         IPOS (K) = JSP1
         JPOS (K) = JSP2
        END IF ! if the point has been previously generated
       END DO ! jsp1
      END DO ! jsp2
    ! include the (i,j) of the current point
      K = K + 1
      IPOS (K) = ISP1
      JPOS (K) = ISP2
    ! ...and save the number of points
      NPTS = K
    ! check that there are at least two points
      IF (K .GE. 2) THEN
     ! ------------------------------------------------------------------------------------
     ! (6) COMPUTE THE CORRELATION AMONG PREVIOUSLY GENERATED POINTS
     ! ------------------------------------------------------------------------------------
       IF (ALLOCATED(CORR)) THEN
        DEALLOCATE (CORR, STAT=IERR)
        IF (IERR .NE. 0) CALL EXIT_SCRF (1, ' probelm deallocating corr ')
       END IF
       IF (ALLOCATED(GVEC)) THEN
        DEALLOCATE (GVEC, STAT=IERR)
        IF (IERR .NE. 0) CALL EXIT_SCRF (1, ' probelm deallocating gvec ')
       END IF
       IF (ALLOCATED(TWGT)) THEN
        DEALLOCATE (TWGT, STAT=IERR)
        IF (IERR .NE. 0) CALL EXIT_SCRF (1, ' probelm deallocating twgt ')
       END IF
       IF (ALLOCATED(INDX)) THEN
        DEALLOCATE (INDX, STAT=IERR)
        IF (IERR .NE. 0) CALL EXIT_SCRF (1, ' probelm deallocating indx ')
       END IF
       ALLOCATE (CORR(K-1, K-1), GVEC(K-1), TWGT(K-1), INDX(K-1), STAT=IERR)
       IF (IERR .NE. 0) CALL EXIT_SCRF (1, ' problem allocating space for corr, gvec, twgt, or indx ')
     ! Note that the vector of previously generated points includes the current point as its
     ! last element.  The correlation among all previously generated points are computed over
     ! elements (1...k-1) and saved in the matrix corr.  The correlation between previously
     ! generated points (1...k-1) and the current point (k) is saved in ther vector gvec.
       DO IPREV = 1, K
        DO JPREV = 1, IPREV
         IF (IPREV .EQ. JPREV) THEN
          IF (IPREV .LE. K-1) CORR (IPREV, JPREV) = 1.0D0 ! grid points are the same, correlation=1
         ELSE
        ! identify lat-lon of previously generated points
          LON1 = grid%LON (IPOS(IPREV), JPOS(IPREV))! NOTE, iprev, lon
          LON2 = grid%LON (IPOS(JPREV), JPOS(JPREV))! NOTE, jprev, lon
          LAT1 = grid%LAT (IPOS(IPREV), JPOS(IPREV))! NOTE, iprev, lat
          LAT2 = grid%LAT (IPOS(JPREV), JPOS(JPREV))! NOTE, jprev, lat
        ! compute distance (km) - on the surface of a sphere
          DIST = 6378.0D0 * Acos (SIND(LAT1)*SIND(LAT2)+COSD(LAT1)*COSD(LAT2)*COSD(LON1-LON2))
        ! compute correlation
          IF (IPREV .LE. K-1) THEN
         ! correlation among all previously generated points (1...k-1,1...k-1) -- corr
           CORR (IPREV, JPREV) = Exp (-(DIST/clen))
           CORR (JPREV, IPREV) = CORR (IPREV, JPREV)
          ELSE
         ! correlation between all previously generated points and the current point -- gvec
           IF (JPREV .LE. K-1) GVEC (JPREV) = Exp (-(DIST/clen))
          END IF ! switch between corr and gvec
         END IF ! if the points are the same
        END DO ! jprev
       END DO ! iprev
     ! ------------------------------------------------------------------------------------
     ! (7) COMPUTE THE WEIGHTS
     ! ------------------------------------------------------------------------------------
     ! Note that the vector of previously generated points includes the current point as its
     ! last element.  The correlation among all previously generated points are computed over
     ! elements (1...k-1) and saved in the matrix corr.  The correlation between previously
     ! generated points (1...k-1) and the current point (k) is saved in ther vector gvec.
     ! special case of the bi-variate normal
       IF (K .EQ. 2) THEN
        WGHT (1) = GVEC (1)
        SDEV = Sqrt (1.-GVEC(1)**2.)
     ! all other points
       ELSE
      ! temporary weight (GVEC is over-written)
        TWGT (1:K-1) = GVEC (1:K-1)
      ! estimate weights
        CALL ludcmp (CORR, INDX, TMP)
        CALL lubksb (CORR, INDX, TWGT)
      ! save weights and variance
        WGHT (1:K-1) = TWGT (1:K-1)
        SDEV = Sqrt (1.-DOT_PRODUCT(GVEC(1:K-1), TWGT(1:K-1)))
       END IF ! ( if k gt 2 )
     ! deallocate correlation arrays
       IF (ALLOCATED(CORR)) THEN
        DEALLOCATE (CORR, STAT=IERR)
        IF (IERR .NE. 0) CALL EXIT_SCRF (1, ' probelm deallocating corr ')
       END IF
       IF (ALLOCATED(GVEC)) THEN
        DEALLOCATE (GVEC, STAT=IERR)
        IF (IERR .NE. 0) CALL EXIT_SCRF (1, ' probelm deallocating gvec ')
       END IF
       IF (ALLOCATED(TWGT)) THEN
        DEALLOCATE (TWGT, STAT=IERR)
        IF (IERR .NE. 0) CALL EXIT_SCRF (1, ' probelm deallocating twgt ')
       END IF
       IF (ALLOCATED(INDX)) THEN
        DEALLOCATE (INDX, STAT=IERR)
        IF (IERR .NE. 0) CALL EXIT_SCRF (1, ' probelm deallocating indx ')
       END IF
      END IF ! ( if k ge 2 )
    ! flag the point as "generated"
      GMSK (ISP1, ISP2) = .TRUE.
    ! -------------------------------------------------------------------------------------
    ! (8) SAVE WEIGHTS IN THE SPATIAL CORRELATION STRUCTURE
    ! -------------------------------------------------------------------------------------
    ! allocate space for the (i,j) position of previously generated points
      IF (ASSOCIATED(SPCORR(ISP1, ISP2)%IPOS)) THEN
       DEALLOCATE (SPCORR(ISP1, ISP2)%IPOS, STAT=IERR)
       IF (IERR .NE. 0) CALL EXIT_SCRF (1, ' problem deallocating space for ipos, jpos ')
      END IF
      IF (ASSOCIATED(SPCORR(ISP1, ISP2)%JPOS)) THEN
       DEALLOCATE (SPCORR(ISP1, ISP2)%JPOS, STAT=IERR)
       IF (IERR .NE. 0) CALL EXIT_SCRF (1, ' problem deallocating space for ipos, jpos ')
      END IF
      ALLOCATE (SPCORR(ISP1, ISP2)%IPOS(NPTS-1), SPCORR(ISP1, ISP2)%JPOS(NPTS-1), STAT=IERR)
      IF (IERR .NE. 0) CALL EXIT_SCRF (1, ' problem allocating space for the (i,j) position of previously generated poi&
     &nts ')
    ! allocate space for the weights assigned to previously generated points
      IF (ASSOCIATED(SPCORR(ISP1, ISP2)%WGHT)) THEN
       DEALLOCATE (SPCORR(ISP1, ISP2)%WGHT, STAT=IERR)
       IF (IERR .NE. 0) CALL EXIT_SCRF (1, ' problem deallocating space for weights assigned to previously generated po&
      &ints ')
      END IF
      ALLOCATE (SPCORR(ISP1, ISP2)%WGHT(NPTS-1), STAT=IERR)
      IF (IERR .NE. 0) CALL EXIT_SCRF (1, ' problem allocating space for weights assigned to previously generated point&
     &s ')
    ! populate the structures (-1 excludes the current (i,j) point)
      SPCORR(ISP1, ISP2)%IPOS(1:NPTS-1) = IPOS (1:NPTS-1)! i-position
      SPCORR(ISP1, ISP2)%JPOS(1:NPTS-1) = JPOS (1:NPTS-1)! j-position
      SPCORR(ISP1, ISP2)%WGHT(1:NPTS-1) = WGHT (1:NPTS-1)! weight assigned to previously generated points
      SPCORR(ISP1, ISP2)%SDEV = SDEV ! standard deviation of estimate
 
    ! deallocate (i,j) position and weights
      IF (ALLOCATED(IPOS)) THEN
       DEALLOCATE (IPOS, STAT=IERR)
       IF (IERR .NE. 0) CALL EXIT_SCRF (1, ' problem deallocating ipos ')
      END IF
      IF (ALLOCATED(JPOS)) THEN
       DEALLOCATE (JPOS, STAT=IERR)
       IF (IERR .NE. 0) CALL EXIT_SCRF (1, ' problem deallocating jpos ')
      END IF
      IF (ALLOCATED(WGHT)) THEN
       DEALLOCATE (WGHT, STAT=IERR)
       IF (IERR .NE. 0) CALL EXIT_SCRF (1, ' problem deallocating wght` ')
      END IF
     END IF ! if the point has not been generated yet
    END DO ! ilat
   END DO ! ilon
  END DO ! ires
! deallocate mask
  IF (ALLOCATED(GMSK)) THEN
   DEALLOCATE (GMSK, STAT=IERR)
   IF (IERR .NE. 0) CALL EXIT_SCRF (1, ' problem deallocating space for mask ')
  END IF
!IF (INIT) INIT=.FALSE.
 
! ----------------------------------------------------------------------------------------
  RETURN
END SUBROUTINE SPCORR_GRD
